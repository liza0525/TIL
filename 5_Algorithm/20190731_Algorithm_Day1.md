# 2019_0731_Algorithm_Day1

- APS : Algorithm problem solving

- 삼성전자에 들어가려면 ad는 따야하고 일이 가능하려면 pro까지는 꼭 해야 함 

  아주 어릴 때부터 했던 거 아니면 export는 기대 ㄴㄴ



## Programming Language

- type
- 제어 <==이 부분이 탄탄해야 후에 실력이 매우 향상될 것이다 / 꼭 할 것!
- 순차 / 선택 / 반복



## 자료구조

ADT(Abstract Data Type)

- 자료
- 연산에 대한 정의(삽입/삭제/**순회**)



### 자료구조의 종류

- 선형 자료구조
  - 배열
  - 리스트
  - 스택
  - 큐



## 비선형 자료구조

element-element 관계가 1:1일지 1:n일지 모른다.

- 트리(Directed Acyclic Graph) : 그래프의 종류 중 하나
- 그래프 (사이클이 있음)

- row-on data : 1, 2, 1, 3, 2, 4, 3, 6 등의 표현으로 입력값이 들어오면 in-out의 관계를 알 수 있다. 하지만 직관적이지 못함
  - 이를 해결하기 위해 행렬 또는 리스트로

- 순회(traversal) : 가장 중요하다
  - 비선형 구조는 한번 지나가면 다시 확인할 수 없기 때문에 애초에 빠짐없이 확인하는 방법
  - Backtracking : 삼성에서 ad를 딴다 하면 제일 많이 씀! DFS가 가장 많이 이용됨

| 비선형자료구조 |          알고리즘 종류          |                             종류                             |
| :------------: | :-----------------------------: | :----------------------------------------------------------: |
|      트리      | pre-order, in-order, post order | 이진트리, 이진탐색트리, AVL, 트라이, 허프만, 아로코라식, 세그먼트 |
|     그래프     |       DFS(스택), BFS(큐)        | MST, 최단경로(다익스트라 알고리즘, TSP<-가장 클래식한 문제, 플로이드, 델만), AOV, AOE, 네트워크, 기하.. |



## 알고리즘

- 검색(ex 해쉬)
- 정렬 : 카운트정렬, 버블정렬 등



## 설계기법

- 그리드(탐욕기법) : 이건 ex정도에서만... pro에게도 벅찬 것임
- 분할정부 : pro/ad의 덕목임 아주 중요함

- 백트래킹(상태 공간 트리, DFS(스택 또는 재귀 이용)/BFS로 돌릴 수도 있다.)
- DP(Dynamic Programming) - 재귀적 DP, 반복적 DP
  - 재귀적 DP : 백트래킹을 기본으로 한다
  - 반복적 DP



**설계기법 이전에 반드시 알아야 하는 개념 : `완전검색(조합론)`**

 - 모든 case를 다 생각해내야 한다. -> 순열(TSP, O(n!)), 조합, 부분집합(배낭문제, O(2^n)을 생성해서 다 조사해내는 것
   	- 순열과 부분집합은 O(지수)의 시간이 걸린다.
	- 삼성에서 물어보는 문제는 완전 검색을 얼마나 잘 구현해내느냐의 이야기

| O(n^k) | O(지수)                                                      |
| ------ | ------------------------------------------------------------ |
| P      | NP(사람이 기다릴 수 없는 시간이 걸린다) -> 근사 알고리즘 또는 인공지능으로 해결(자료구조는 Tree) |



## 강의노트 정리 - APS Python 기본

### **알고리즘**이란 ? 

유한한 단계를 통해 문제를 해결하기 위한 절차나 방법

 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법



### 알고리즘을 표현하는 방법

슈더코드(수도코드) 또는 순서도



### 알고리즘의 성능 측정

정확성과 작업량에 초점, 하지만 정확성이 제일 중요하다!! 정확하게 짜고, 시간을 줄이는 방법으로 접근하자.

- 정확성
- 작업량 : 시간은 OS마다 다르기 때문에, 명령어 기준으로 생각하도록 하자, n개의 명령어가 들어오면 O(n^2)
- 메모리 사용량 : 굉장히 중요한 이슈, 우주 항공기 같은 곳은 메모리가 매우 한계가 있기 때문에 생각한다.(물론 검정 땐 별로 안 중요함)
- 단순성 : 검정에선 중요하지 않지만 사람과의 협업에 있어서 중요하다. 구글에서는 4중 for문을 쓰려고 하면 (상사로부터) 결재를 받아야 했다.
- 최적화



### 시간복잡도 : 빅오(O)표기법

- 시간 복잡도의 경우에는 함수에서 가장 큰 영향력을 주는 n에 대한 항(최고차항)만 표현하기 => 최고차항의 입장에서 그보다 작은 차항들의 값들은 별로 영향력이 없기 때문에
- 계수는 삭제한다
  - ex) O(3n+2)  ==> O(3n) ==> O(n)



### 배열이란?

일정한 자료형의 변수를 한번에 처리하기 위함 -> 반복문과 케미가 좋다!

- 파이썬에서의 배열 선언 : arr = list[]



### 예제

- Gravity(배열 활용) : 완전 탐색 이용
  - http://dailyddubby.blogspot.com/2018/03/56-gravity.html
- Baby-gin Game : 완전 탐색 이용
  - 32p. continue의 의미 : triplet이 두 개가 있을 수 있기 때문에 한번 더 확인하겠다는 것(코드 뿌셔보기 ㅎㅎ)
  - if문 두 개를 위치를 바꿔도 되는가? => 안 된다. baby-gin이 가능한대도 가능하지 않다고 할 수 있기 때문



### 완전 검색(Exhaustive Search)

- 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법.
- Brute-force 혹은 generate-and-test 기법이라고도 함(백트래킹과 케미 굿 하지만 시간 복잡도↑)
- 모든 경우의 수를 테스트한 후 최종 해법 도출
- 일반적으로 경우의 수가 상대적으로 작을 때 유용
- 수행속도는 느리지만, 해답을 못 찾을 확률이 적다.
- 먼저 완전 검색으로 접근한 후 성능 개선을 위해 다른 알고리즘을 사용해보고 해답 찾는 것이 바람직하다.

- 예외가 있는가? ==> 없어야 완전 검색이 가능
- **무조건 시작은 완전 검색으로 해서 가능한 알고리즘인지 생각하는 것!!!**



### 탐욕(Greedy) 알고리즘

- 최적해를 구하는 데에 사용되는 방법
- 매 순간에 최적이라고 생각하는 것만 선택해 나가는 방식으로 진행
- 각 선택이 지역적인 최적이라 하더라도 최종적인 답이 최적이라는 보장은 x
  - 그래프의 시작에서 cost가 가장 작은 것을 고른다 하여, 전체 cost가 제일 작다고 할 수 없다.
- 검증 없이 바로 구현하면 Greedy 접근이 된다. => 검증을 하지 않은 경우 탐욕 접근은 틀릴 가능성이 매우 높다.



### 정렬

2개 이상의 자료를 특정 기준에 의해 오름차순/내림차순으로 재배열

- O(n^2) : 버블 정렬, 삽입 정렬, 선택 정렬

- O(n*log(n)): 퀵 정렬, 병합 정렬, 힙 정렬

- O(n) : 카운트 정렬(디테일하게 말하자면 O(n+k), k는 n에 depend하다고 말함)

  ==> 도대체 왜 쓰는데? 같은 값이라도 순서가 중요할 때 쓴다.



## 기타

- pro는 이 모든 것을 개념적으로 다 알아야 한다.

- 당분간은 과제할 때 라이브러리 절대 쓰지 않고 연습할 것 그래야 ad는 딸 수 있을 것이야...

  함수도 당분간은 쓰지 말 것

- ad의 소양 : 같은 완전탐색이어도 순열 대신 조합을 쓰도록 한다

  ex의 소양 : 너비 요소 탐색으로 찾는다.